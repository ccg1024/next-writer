import { NW_ENV } from 'bin/index.es';
import { BrowserWindow, BrowserWindowConstructorOptions, Menu } from 'electron';
import fs from 'fs';
import path from 'path';
import CacheSystem from './cache/index';
import IpcServer from './ipc/server';
import NextWriterMenu from './menu/next-menu';
import FileSystem from './sys/file-system';
import MainGlobal from './sys/main-global';
import SysInit from './sys/sys-init';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// ============================================================
// This file is used to record the files managed by next-writer
// in the workstation.
// ============================================================
const WORKSTATION_JSON = '.nwriter.info.json';

const DEFAULT_WINDOW: BrowserWindowConstructorOptions = {
  height: 725,
  width: 1180,
  minWidth: 1000,
  minHeight: 400,
  frame: false,
  titleBarStyle: 'hidden',
  trafficLightPosition: { x: 28, y: 15 },
  vibrancy: 'under-window',
  visualEffectState: 'active',
  webPreferences: {
    preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    nodeIntegration: true,
    contextIsolation: true
  }
};

/**
 * A factory class, which to create next-writer application and start server
 *
 * @dependence SysInit
 *
 * @author crazycodegame
 */
class NextWriter {
  private _sysInit: SysInit;
  private _win: BrowserWindow;
  private cache: CacheSystem;
  private _menu: NextWriterMenu;
  private _ipcServer: IpcServer;
  private _mainGlobal: MainGlobal;
  private _fileSystem: FileSystem;

  constructor() {
    this._mainGlobal = new MainGlobal();
    this._fileSystem = new FileSystem(this._mainGlobal);
    this._ipcServer = new IpcServer(this._fileSystem, this._mainGlobal);
    this._sysInit = new SysInit(this._fileSystem, this._mainGlobal, this._ipcServer);

    this.createWindow = this.createWindow.bind(this);
    this.destroy = this.destroy.bind(this);
  }

  /**
   * Create a browser window, this method will assign the window instance to a private variable `win`
   */
  createWindow() {
    // If there already have a instance, close all listener of this instance
    if (this._win) {
      this._win.removeAllListeners();
    }
    this._win = new BrowserWindow(DEFAULT_WINDOW);

    // Open the DevTools in development environment
    if (NW_ENV === 'DEV') {
      this._win.webContents.openDevTools();
    }

    // Initial application system
    this._sysInit.init();

    // Create menu
    this.createMenu();

    // Create cache
    this.cache = new CacheSystem(this._win);

    // Read workstation record info
    this.readWorkstationRecord();

    // Load renderer process
    this._win.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Apply self-check before closing the app
    this._win.on('close', async e => {
      if (this.cache.hasModifiedFile()) {
        const stopClose = await this._fileSystem.showMessageDialog(
          this._win,
          '[next-writer] 有文件未保存，是否关闭应用？',
          { type: 'warning' }
        );
        if (stopClose) {
          e.preventDefault();
          return;
        }
      }
      this._win.removeAllListeners();
      this.destroy();
    });
  }

  /**
   * Mount Application menu
   */
  createMenu() {
    this._menu = new NextWriterMenu();
    Menu.setApplicationMenu(Menu.buildFromTemplate(this._menu.createMenus()));
  }

  /**
   * Read workstation record file - `${WORKSTATION}\/.nwriter.info.json`
   */
  readWorkstationRecord() {
    const root = this._mainGlobal.getConfig('rootDir');
    if (!root) {
      return Promise.reject('[next-writer] The root dir is empty');
    }
    const recordPath = path.resolve(root, WORKSTATION_JSON);

    if (!fs.existsSync(root)) {
      fs.mkdirSync(root, { recursive: true });
    }

    if (!fs.existsSync(recordPath)) {
      fs.promises.writeFile(recordPath, JSON.stringify({ tree: [] }, null, 2)).catch(err => {
        throw err;
      });
      return;
    }

    const buffer = fs.readFileSync(recordPath, { encoding: 'utf8' });
    const record = JSON.parse(buffer.toString());
    this._fileSystem.setTree(record.tree);
  }

  /**
   * Run every destroy method of next-writer dependence.
   */
  destroy() {
    this._ipcServer.destroy();
  }
}

export default new NextWriter();
